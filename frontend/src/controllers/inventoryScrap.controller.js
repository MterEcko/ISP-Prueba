// backend/src/controllers/inventoryScrap.controller.js
const db = require("../models");
const InventoryScrap = db.InventoryScrap;
const Inventory = db.Inventory;
const User = db.User;
const Ticket = db.Ticket;

exports.getAll = async (req, res) => {
  try {
    const { inventoryId, technicianId, ticketId, startDate, endDate, page = 1, limit = 50 } = req.query;
    const offset = (page - 1) * limit;
    const where = {};

    if (inventoryId) where.inventoryId = inventoryId;
    if (technicianId) where.technicianId = technicianId;
    if (ticketId) where.ticketId = ticketId;
    if (startDate && endDate) {
      where.scrapDate = { [db.Sequelize.Op.between]: [startDate, endDate] };
    }

    const scraps = await InventoryScrap.findAndCountAll({
      where,
      include: [
        { model: Inventory, as: 'inventory', attributes: ['id', 'serial', 'status'] },
        { model: User, as: 'technician', attributes: ['id', 'name', 'email'] },
        { model: Ticket, as: 'ticket', attributes: ['id', 'title', 'status'] }
      ],
      limit: parseInt(limit),
      offset: parseInt(offset),
      order: [['scrapDate', 'DESC']]
    });

    return res.status(200).json({
      success: true,
      data: scraps.rows,
      pagination: {
        total: scraps.count,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(scraps.count / limit)
      }
    });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
};

exports.getById = async (req, res) => {
  try {
    const scrap = await InventoryScrap.findByPk(req.params.id, {
      include: [
        { model: Inventory, as: 'inventory' },
        { model: User, as: 'technician', attributes: ['id', 'name', 'email'] },
        { model: Ticket, as: 'ticket' }
      ]
    });

    if (!scrap) {
      return res.status(404).json({ success: false, message: "Registro de scrap no encontrado" });
    }

    return res.status(200).json({ success: true, data: scrap });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
};

exports.create = async (req, res) => {
  try {
    const {
      inventoryId, originalQuantity, usedQuantity, scrapQuantity, scrapReason,
      technicianId, ticketId, costImpact, unitType, scrapThreshold, autoGenerated, notes
    } = req.body;

    if (!inventoryId || !originalQuantity || usedQuantity === undefined || scrapQuantity === undefined) {
      return res.status(400).json({
        success: false,
        message: "inventoryId, originalQuantity, usedQuantity y scrapQuantity son obligatorios"
      });
    }

    const inventory = await Inventory.findByPk(inventoryId);
    if (!inventory) {
      return res.status(404).json({ success: false, message: "Item de inventario no encontrado" });
    }

    // Calcular eficiencia
    const efficiency = originalQuantity > 0 ? (usedQuantity / originalQuantity * 100) : 0;

    const scrap = await InventoryScrap.create({
      inventoryId,
      originalQuantity,
      usedQuantity,
      scrapQuantity,
      scrapReason,
      technicianId,
      ticketId,
      costImpact: costImpact || 0,
      efficiency: efficiency.toFixed(2),
      unitType: unitType || 'piece',
      scrapThreshold,
      autoGenerated: autoGenerated !== undefined ? autoGenerated : true,
      notes
    });

    return res.status(201).json({ success: true, message: "Registro de scrap creado exitosamente", data: scrap });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
};

exports.update = async (req, res) => {
  try {
    const scrap = await InventoryScrap.findByPk(req.params.id);
    if (!scrap) {
      return res.status(404).json({ success: false, message: "Registro de scrap no encontrado" });
    }

    const { usedQuantity, scrapQuantity, scrapReason, costImpact, notes } = req.body;

    // Recalcular eficiencia si cambian las cantidades
    let efficiency = scrap.efficiency;
    if (usedQuantity !== undefined) {
      efficiency = scrap.originalQuantity > 0 ? (usedQuantity / scrap.originalQuantity * 100) : 0;
    }

    await scrap.update({
      usedQuantity: usedQuantity !== undefined ? usedQuantity : scrap.usedQuantity,
      scrapQuantity: scrapQuantity !== undefined ? scrapQuantity : scrap.scrapQuantity,
      scrapReason: scrapReason !== undefined ? scrapReason : scrap.scrapReason,
      costImpact: costImpact !== undefined ? costImpact : scrap.costImpact,
      efficiency: efficiency.toFixed ? efficiency.toFixed(2) : efficiency,
      notes: notes !== undefined ? notes : scrap.notes
    });

    return res.status(200).json({ success: true, message: "Registro de scrap actualizado exitosamente", data: scrap });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
};

exports.delete = async (req, res) => {
  try {
    const scrap = await InventoryScrap.findByPk(req.params.id);
    if (!scrap) {
      return res.status(404).json({ success: false, message: "Registro de scrap no encontrado" });
    }

    await scrap.destroy();
    return res.status(200).json({ success: true, message: "Registro de scrap eliminado exitosamente" });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
};

// Obtener estadÃ­sticas de scrap
exports.getStatistics = async (req, res) => {
  try {
    const { technicianId, startDate, endDate } = req.query;
    const where = {};

    if (technicianId) where.technicianId = technicianId;
    if (startDate && endDate) {
      where.scrapDate = { [db.Sequelize.Op.between]: [startDate, endDate] };
    }

    const stats = await InventoryScrap.findAll({
      where,
      attributes: [
        [db.Sequelize.fn('COUNT', db.Sequelize.col('id')), 'totalRecords'],
        [db.Sequelize.fn('SUM', db.Sequelize.col('scrapQuantity')), 'totalScrapQuantity'],
        [db.Sequelize.fn('SUM', db.Sequelize.col('usedQuantity')), 'totalUsedQuantity'],
        [db.Sequelize.fn('SUM', db.Sequelize.col('costImpact')), 'totalCostImpact'],
        [db.Sequelize.fn('AVG', db.Sequelize.col('efficiency')), 'averageEfficiency']
      ]
    });

    return res.status(200).json({ success: true, data: stats[0] });
  } catch (error) {
    return res.status(500).json({ success: false, message: error.message });
  }
};
